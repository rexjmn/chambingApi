Enter your prompt here

# Project Structure

├─ 📁 src
  ├─ 📁 config
    └─ database.config.ts
    └─ cors.config.ts
  ├─ 📁 modules
    ├─ 📁 contracts
      ├─ 📁 entities
        └─ estado-contrato.entity.ts
        └─ contrato.entity.ts
      ├─ 📁 dto
        └─ update-contrato.dto.ts
        └─ create-estado-contrato.dto.ts
        └─ create-contrato.dto.ts
      └─ contracts.service.ts
      └─ contracts.module.ts
      └─ contracts.controller.ts
    ├─ 📁 services
      ├─ 📁 entities
        └─ trabajador-categoria.entity.ts
        └─ tarifa-categoria.entity.ts
        └─ categoria-servicio.entity.ts
      ├─ 📁 dto
        └─ create-trabajador-categoria.dto.ts
        └─ create-tarifa.dto.ts
        └─ create-categoria.dto.ts
      └─ services.service.ts
      └─ services.module.ts
      └─ services.controller.ts
    ├─ 📁 users
      ├─ 📁 entities
        └─ user.entity.ts
      ├─ 📁 dto
        └─ create-user.dto.ts
        └─ update-profile-photo.dto.ts
      └─ users.service.ts
      └─ users.module.ts
      └─ users.controller.ts
    ├─ 📁 documents
      ├─ 📁 entities
        └─ documento-trabajador.entity.ts
      ├─ 📁 dto
        └─ update-documento.dto.ts
        └─ create-documento.dto.ts
      └─ documents.service.ts
      └─ documents.module.ts
      └─ documents.controller.ts
    ├─ 📁 aws
      └─ aws.service.ts
      └─ aws.module.ts
      └─ aws.controller.ts
    ├─ 📁 roles
      ├─ 📁 entities
        └─ role.entity.ts
        └─ rol-administrativo.entity.ts
      ├─ 📁 dto
        └─ create-role.dto.ts
        └─ create-rol-administrativo.dto.ts
        └─ update-role.dto.ts
      └─ roles.controller.ts
      └─ roles.service.ts
      └─ roles.module.ts
  ├─ 📁 common
    ├─ 📁 interceptors
      └─ transform.interceptor.ts
      └─ logging.interceptor.ts
    ├─ 📁 dto
      └─ response.dto.ts
      └─ pagination.dto.ts
  ├─ 📁 auth
    ├─ 📁 strategies
      └─ jwt.strategy.ts
    ├─ 📁 dto
      └─ login.dto.ts
    ├─ 📁 guards
      └─ roles.guard.ts
      └─ jwt-auth.guard.ts
    ├─ 📁 decorators
      └─ roles.decorator.ts
    ├─ 📁 interfaces
      └─ jwt-payload.interface.ts
    └─ auth.service.ts
    └─ auth.module.ts
    └─ auth.controller.ts
  └─ main.ts
  └─ app.module.ts
  └─ app.controller.ts
├─ 📁 test
  └─ jest-e2e.json
  └─ app.e2e-spec.ts
└─ tsconfig.json
└─ README.md
└─ package.json
└─ package-lock.json
└─ nest-cli.json
└─ eslint.config.mjs
└─ .prettierrc


# Project Files

- c:\Users\rexma\Desktop\freelance-app\src\modules\users\users.service.ts
- c:\Users\rexma\Desktop\freelance-app\src\modules\users\users.controller.ts
- c:\Users\rexma\Desktop\freelance-app\src\modules\users\users.module.ts
- c:\Users\rexma\Desktop\freelance-app\src\modules\aws\aws.service.ts
- c:\Users\rexma\Desktop\freelance-app\src\app.module.ts

## c:\Users\rexma\Desktop\freelance-app\src\modules\users\users.service.ts
```
import { Injectable, NotFoundException, ConflictException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateProfilePhotoDto } from './dto/update-profile-photo.dto'; 
import { AwsService } from '../aws/aws.service';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private usersRepository: Repository<User>,
    private readonly awsService: AwsService
  ) {}

  async updateProfilePhoto(userId: string, file: Express.Multer.File): Promise<User> {
    const user = await this.findOne(userId);

    try {
      // Si el usuario ya tiene una foto, eliminarla de S3
      if (user.foto_perfil) {
        const oldKey = this.getKeyFromUrl(user.foto_perfil);
        if (oldKey) {
          await this.awsService.deleteFile(oldKey);
        }
      }

      // Subir nueva foto
      const { fileUrl } = await this.awsService.uploadFile(file);
      
      // Actualizar usuario
      user.foto_perfil = fileUrl;
      return await this.usersRepository.save(user);
    } catch (error) {
      throw new BadRequestException('Error actualizando foto de perfil');
    }
  }

  private getKeyFromUrl(url: string): string | null {
    try {
      const urlObj = new URL(url);
      return urlObj.pathname.substring(1);
    } catch {
      return null;
    }
  }

  async create(createUserDto: CreateUserDto): Promise<User> {
    // Verificar si el email ya existe
    const existingUser = await this.usersRepository.findOne({
      where: { email: createUserDto.email }
    });
  
    if (existingUser) {
      throw new ConflictException('El email ya está registrado');
    }
    if (createUserDto.tipo_usuario === 'trabajador' && !createUserDto.foto_perfil) {
      throw new BadRequestException('La foto de perfil es obligatoria para trabajadores');
    }
  
    const user = this.usersRepository.create({
      ...createUserDto,
      tipo_usuario: createUserDto.tipo_usuario || 'regular', // Aseguramos que siempre tenga un valor
      activo: true
    });
    
    return await this.usersRepository.save(user);
  }

  async findOne(id: string): Promise<User> {
    const user = await this.usersRepository.findOne({ 
      where: { id },
      relations: ['rolesAdministrativos', 'rolesAdministrativos.rol']
    });
    if (!user) {
      throw new NotFoundException('Usuario no encontrado');
    }
    return user;
  }

  async findByEmail(email: string): Promise<User> {
    const user = await this.usersRepository.findOne({ 
      where: { email },
      relations: ['rolesAdministrativos', 'rolesAdministrativos.rol']
    });
    if (!user) {
      throw new NotFoundException('Usuario no encontrado');
    }
    return user;
  }

  async updatePassword(id: string, hashedPassword: string): Promise<void> {
    const user = await this.usersRepository.findOne({ where: { id } });
    if (!user) {
      throw new NotFoundException('Usuario no encontrado');
    }
    
    user.password = hashedPassword;
    await this.usersRepository.save(user);
  }

  async getUserRoles(userId: string): Promise<string[]> {
    const user = await this.usersRepository.findOne({
      where: { id: userId },
      relations: ['rolesAdministrativos', 'rolesAdministrativos.rol']
    });

    if (!user) {
      throw new NotFoundException('Usuario no encontrado');
    }

    return user.rolesAdministrativos
      .filter(ra => ra.activo)
      .map(ra => ra.rol.nombre);
  }
}



```

## c:\Users\rexma\Desktop\freelance-app\src\modules\users\users.controller.ts
```
// src/modules/users/users.controller.ts
import { Controller, Post, Body, Get, UseGuards, Req, UploadedFile, UseInterceptors, BadRequestException } from '@nestjs/common';
import { UsersService } from './users.service';
import { FileInterceptor } from '@nestjs/platform-express';
import { CreateUserDto } from './dto/create-user.dto';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import * as bcrypt from 'bcrypt';
import { Request, Express } from 'express';

interface RequestWithUser extends Request {
  user: {
    id: string;
    email: string;
    roles: string[];
  };
}

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post('profile-photo')
  @UseGuards(JwtAuthGuard)
  @UseInterceptors(FileInterceptor('file', {
    limits: {
      fileSize: 5 * 1024 * 1024, // 5MB
    },
    fileFilter: (req, file, cb) => {
      if (!file.mimetype.match(/^image\/(jpg|jpeg|png|gif)$/)) {
        cb(new BadRequestException('Solo se permiten imágenes'), false);
      }
      cb(null, true);
    },
  }))
  async updateProfilePhoto(
    @UploadedFile() file: Express.Multer.File,
    @Req() req: RequestWithUser
  ) {
    try {
      const updatedUser = await this.usersService.updateProfilePhoto(
        req.user.id,
        file
      );

      return {
        status: 'success',
        message: 'Foto de perfil actualizada exitosamente',
        data: {
          id: updatedUser.id,
          foto_perfil: updatedUser.foto_perfil,
          updatedAt: new Date()
        }
      };
    } catch (error) {
      throw new BadRequestException(error.message);
    }
  }

  @Post('register')
  async register(@Body() createUserDto: CreateUserDto) {
    // Hash de la contraseña antes de crear el usuario
    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);
    
    // Crear usuario con la contraseña hasheada
    const user = await this.usersService.create({
      ...createUserDto,
      password: hashedPassword
    });

    // Retornar el usuario sin la contraseña
    const { password, ...result } = user;
    return {
      status: 'success',
      message: 'Usuario registrado exitosamente',
      data: result
    };
  }

  @Get('profile')
  @UseGuards(JwtAuthGuard)
  async getProfile(@Req() req: RequestWithUser) {
    const user = await this.usersService.findOne(req.user.id);
    const { password, ...result } = user;
    return {
      status: 'success',
      data: result
    };
  }

  @Get('me')
  @UseGuards(JwtAuthGuard)
  async getMe(@Req() req: RequestWithUser) {
    const user = await this.usersService.findOne(req.user.id);
    const { password, ...result } = user;
    return {
      status: 'success',
      data: {
        ...result,
        roles: await this.usersService.getUserRoles(req.user.id)
      }
    };
  }
}
```

## c:\Users\rexma\Desktop\freelance-app\src\modules\users\users.module.ts
```
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { AwsModule } from '../aws/aws.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([User]),
    AwsModule
  ],
  providers: [UsersService],
  controllers: [UsersController],
  exports: [UsersService],
})
export class UsersModule {}
```

## c:\Users\rexma\Desktop\freelance-app\src\modules\aws\aws.service.ts
```
// src/modules/aws/aws.service.ts
import { Injectable, BadRequestException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { S3Client, PutObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class AwsService {
  private s3Client: S3Client;
  private readonly bucketName: string;
  private readonly region: string;

  constructor(private configService: ConfigService) {
    // Obtener y validar configuraciones
    const region = this.configService.get<string>('AWS_REGION');
    const accessKeyId = this.configService.get<string>('AWS_ACCESS_KEY_ID');
    const secretAccessKey = this.configService.get<string>('AWS_SECRET_ACCESS_KEY');
    const bucketName = this.configService.get<string>('AWS_BUCKET_NAME');

    // Validar que todas las configuraciones existan
    if (!region || !accessKeyId || !secretAccessKey || !bucketName) {
      throw new Error('AWS credentials are missing');
    }

    this.bucketName = bucketName;
    this.s3Client = new S3Client({
      region,
      credentials: {
        accessKeyId,
        secretAccessKey,
      }
    });
  }

  async generateUploadUrl(
    folder: string,
    fileExtension: string | undefined,
    contentType: string
  ): Promise<{ uploadUrl: string; fileKey: string }> {
    try {
      // Validar tipo de archivo
      if (!this.isValidFileType(contentType)) {
        throw new BadRequestException('Tipo de archivo no permitido');
      }

      // Asegurar que tenemos una extensión válida
      const extension = fileExtension || this.getDefaultExtension(contentType);

      // Generar nombre único para el archivo
      const fileKey = `${folder}/${uuidv4()}.${extension}`;

      const command = new PutObjectCommand({
        Bucket: this.bucketName,
        Key: fileKey,
        ContentType: contentType,
      });

      const uploadUrl = await getSignedUrl(this.s3Client, command, { 
        expiresIn: 3600 
      });

      return { uploadUrl, fileKey };

    } catch (error) {
      console.error('Error generando URL de subida:', error);
      throw new Error('Error generando URL para subida de archivo');
    }
  }

  async deleteFile(fileKey: string): Promise<void> {
    try {
      const command = new DeleteObjectCommand({
        Bucket: this.bucketName,
        Key: fileKey
      });

      await this.s3Client.send(command);
      console.log(`File ${fileKey} deleted successfully from S3`);
    } catch (error) {
      console.error('Error deleting file from S3:', error);
      throw new BadRequestException('Error deleting file from S3');
    }
  }


  private isValidFileType(contentType: string): boolean {
    const allowedTypes = [
      'image/jpeg',
      'image/png',
      'image/webp',
      'application/pdf'
    ];
    return allowedTypes.includes(contentType);
  }

  private getDefaultExtension(contentType: string): string {
    const mimeToExt = {
      'image/jpeg': 'jpg',
      'image/png': 'png',
      'image/webp': 'webp',
      'application/pdf': 'pdf'
    };
    return mimeToExt[contentType] || 'bin';
  }

  async uploadFile(file: Express.Multer.File): Promise<{ fileUrl: string }> {
    try {
      // Validar el archivo
      if (!file) {
        throw new BadRequestException('No file provided');
      }

      // Validar tipo de archivo
      if (!this.isValidFileType(file.mimetype)) {
        throw new BadRequestException('Invalid file type');
      }

      const fileExtension = file.originalname.split('.').pop() || 
                          this.getDefaultExtension(file.mimetype);
      
      const fileKey = `test-uploads/${uuidv4()}.${fileExtension}`;

      const command = new PutObjectCommand({
        Bucket: this.bucketName,
        Key: fileKey,
        Body: file.buffer,
        ContentType: file.mimetype
      });

      await this.s3Client.send(command);

      const fileUrl = `https://${this.bucketName}.s3.${this.region}.amazonaws.com/${fileKey}`;

      return { fileUrl };

    } catch (error) {
      console.error('Error uploading file:', error);
      throw new BadRequestException('Error uploading file to S3');
    }
  }
}
```

## c:\Users\rexma\Desktop\freelance-app\src\app.module.ts
```
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import databaseConfig from './config/database.config';
import { AuthModule } from './auth/auth.module';
import { UsersModule } from './modules/users/users.module';
import { RolesModule } from './modules/roles/roles.module';
import { ServicesModule } from './modules/services/services.module';
import { ContractsModule } from './modules/contracts/contracts.module';
import { DocumentsModule } from './modules/documents/documents.module';
import { AppController } from './app.controller'; // Corregida la importación
import { AwsModule } from './modules/aws/aws.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [databaseConfig],
    }),
    TypeOrmModule.forRootAsync({
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => {
        const dbConfig = configService.get('database');
        return {
          ...dbConfig,
          autoLoadEntities: true,
        };
      },
    }),
    AuthModule,
    UsersModule,
    RolesModule,
    ServicesModule,
    ContractsModule,
    DocumentsModule,
    AwsModule,
  ],
  controllers: [AppController],
})
export class AppModule {}
```

