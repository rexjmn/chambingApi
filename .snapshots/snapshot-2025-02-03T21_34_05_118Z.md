Enter your prompt here

# Project Structure

‚îú‚îÄ üìÅ src
  ‚îú‚îÄ üìÅ modules
    ‚îú‚îÄ üìÅ users
      ‚îú‚îÄ üìÅ entities
        ‚îî‚îÄ user.entity.ts
      ‚îú‚îÄ üìÅ dto
        ‚îî‚îÄ update-profile-photo.dto.ts
        ‚îî‚îÄ create-user.dto.ts
      ‚îî‚îÄ users.service.ts
      ‚îî‚îÄ users.module.ts
      ‚îî‚îÄ users.controller.ts
    ‚îú‚îÄ üìÅ services
      ‚îú‚îÄ üìÅ entities
        ‚îî‚îÄ trabajador-categoria.entity.ts
        ‚îî‚îÄ tarifa-categoria.entity.ts
        ‚îî‚îÄ categoria-servicio.entity.ts
      ‚îú‚îÄ üìÅ dto
        ‚îî‚îÄ create-trabajador-categoria.dto.ts
        ‚îî‚îÄ create-tarifa.dto.ts
        ‚îî‚îÄ create-categoria.dto.ts
      ‚îî‚îÄ services.service.ts
      ‚îî‚îÄ services.module.ts
      ‚îî‚îÄ services.controller.ts
    ‚îú‚îÄ üìÅ documents
      ‚îú‚îÄ üìÅ entities
        ‚îî‚îÄ documento-trabajador.entity.ts
      ‚îú‚îÄ üìÅ dto
        ‚îî‚îÄ update-documento.dto.ts
        ‚îî‚îÄ create-documento.dto.ts
      ‚îî‚îÄ documents.service.ts
      ‚îî‚îÄ documents.module.ts
      ‚îî‚îÄ documents.controller.ts
    ‚îú‚îÄ üìÅ roles
      ‚îú‚îÄ üìÅ dto
        ‚îî‚îÄ update-role.dto.ts
        ‚îî‚îÄ create-role.dto.ts
        ‚îî‚îÄ create-rol-administrativo.dto.ts
      ‚îú‚îÄ üìÅ entities
        ‚îî‚îÄ role.entity.ts
        ‚îî‚îÄ rol-administrativo.entity.ts
      ‚îî‚îÄ roles.service.ts
      ‚îî‚îÄ roles.module.ts
      ‚îî‚îÄ roles.controller.ts
    ‚îú‚îÄ üìÅ aws
      ‚îî‚îÄ aws.service.ts
      ‚îî‚îÄ aws.module.ts
      ‚îî‚îÄ aws.controller.ts
    ‚îú‚îÄ üìÅ contracts
      ‚îú‚îÄ üìÅ entities
        ‚îî‚îÄ estado-contrato.entity.ts
        ‚îî‚îÄ contrato.entity.ts
      ‚îú‚îÄ üìÅ dto
        ‚îî‚îÄ update-contrato.dto.ts
        ‚îî‚îÄ create-estado-contrato.dto.ts
        ‚îî‚îÄ create-contrato.dto.ts
      ‚îî‚îÄ contracts.service.ts
      ‚îî‚îÄ contracts.module.ts
      ‚îî‚îÄ contracts.controller.ts
  ‚îú‚îÄ üìÅ database
    ‚îú‚îÄ üìÅ migrations
      ‚îî‚îÄ 1709123456789-CreateRefreshTokensTable.ts
  ‚îú‚îÄ üìÅ config
    ‚îî‚îÄ database.config.ts
    ‚îî‚îÄ cors.config.ts
  ‚îú‚îÄ üìÅ auth
    ‚îú‚îÄ üìÅ strategies
      ‚îî‚îÄ jwt.strategy.ts
    ‚îú‚îÄ üìÅ services
      ‚îî‚îÄ token.service.ts
      ‚îî‚îÄ login-attempt.service.ts
    ‚îú‚îÄ üìÅ interfaces
      ‚îî‚îÄ jwt-payload.interface.ts
      ‚îî‚îÄ auth-tokens.interface.ts
    ‚îú‚îÄ üìÅ decorators
      ‚îî‚îÄ roles.decorator.ts
    ‚îú‚îÄ üìÅ dto
      ‚îî‚îÄ login.dto.ts
    ‚îú‚îÄ üìÅ entities
      ‚îî‚îÄ refresh-token.entity.ts
      ‚îî‚îÄ login-attempt.entity.ts
    ‚îú‚îÄ üìÅ guards
      ‚îî‚îÄ roles.guard.ts
      ‚îî‚îÄ jwt-auth.guard.ts
    ‚îî‚îÄ auth.controller.ts
    ‚îî‚îÄ auth.module.ts
    ‚îî‚îÄ auth.service.ts
  ‚îú‚îÄ üìÅ common
    ‚îú‚îÄ üìÅ dto
      ‚îî‚îÄ response.dto.ts
      ‚îî‚îÄ pagination.dto.ts
    ‚îú‚îÄ üìÅ interceptors
      ‚îî‚îÄ transform.interceptor.ts
      ‚îî‚îÄ logging.interceptor.ts
  ‚îî‚îÄ main.ts
  ‚îî‚îÄ app.module.ts
  ‚îî‚îÄ app.controller.ts
‚îú‚îÄ üìÅ test
  ‚îî‚îÄ jest-e2e.json
  ‚îî‚îÄ app.e2e-spec.ts
‚îî‚îÄ package.json
‚îî‚îÄ README.md
‚îî‚îÄ package-lock.json
‚îî‚îÄ tsconfig.json
‚îî‚îÄ nest-cli.json
‚îî‚îÄ eslint.config.mjs
‚îî‚îÄ .prettierrc


# Project Files

- c:\Users\rexma\Desktop\freelance-app\src\modules\users\users.module.ts
- c:\Users\rexma\Desktop\freelance-app\src\modules\aws\aws.service.ts
- c:\Users\rexma\Desktop\freelance-app\src\app.module.ts
- c:\Users\rexma\Desktop\freelance-app\src\modules\aws\aws.module.ts
- c:\Users\rexma\Desktop\freelance-app\src\modules\users\users.controller.ts
- c:\Users\rexma\Desktop\freelance-app\src\auth\strategies\jwt.strategy.ts
- c:\Users\rexma\Desktop\freelance-app\src\auth\guards\jwt-auth.guard.ts
- c:\Users\rexma\Desktop\freelance-app\src\auth\auth.module.ts
- c:\Users\rexma\Desktop\freelance-app\src\auth\entities\refresh-token.entity.ts
- c:\Users\rexma\Desktop\freelance-app\src\auth\services\token.service.ts
- c:\Users\rexma\Desktop\freelance-app\src\auth\entities\login-attempt.entity.ts
- c:\Users\rexma\Desktop\freelance-app\src\auth\services\login-attempt.service.ts
- c:\Users\rexma\Desktop\freelance-app\src\database\migrations\1709123456789-CreateRefreshTokensTable.ts
- c:\Users\rexma\Desktop\freelance-app\src\auth\interfaces\auth-tokens.interface.ts
- c:\Users\rexma\Desktop\freelance-app\src\auth\interfaces\jwt-payload.interface.ts

## c:\Users\rexma\Desktop\freelance-app\src\modules\users\users.module.ts
```
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { AwsModule } from '../aws/aws.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([User]),
    forwardRef(() => AwsModule)
  ],
  providers: [UsersService],
  controllers: [UsersController],
  exports: [UsersService],
})
export class UsersModule {}
```

## c:\Users\rexma\Desktop\freelance-app\src\modules\aws\aws.service.ts
```
// src/modules/aws/aws.service.ts
import { Injectable, BadRequestException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { S3Client, PutObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class AwsService {
  private s3Client: S3Client;
  private readonly bucketName: string;
  private readonly region: string;

  constructor(private configService: ConfigService) {
    // Obtener y validar configuraciones
    const region = this.configService.get<string>('AWS_REGION');
    const accessKeyId = this.configService.get<string>('AWS_ACCESS_KEY_ID');
    const secretAccessKey = this.configService.get<string>('AWS_SECRET_ACCESS_KEY');
    const bucketName = this.configService.get<string>('AWS_BUCKET_NAME');

    // Validar que todas las configuraciones existan
    if (!region || !accessKeyId || !secretAccessKey || !bucketName) {
      throw new Error('AWS credentials are missing');
    }

    this.bucketName = bucketName;
    this.s3Client = new S3Client({
      region,
      credentials: {
        accessKeyId,
        secretAccessKey,
      }
    });
  }

  async generateUploadUrl(
    folder: string,
    fileExtension: string | undefined,
    contentType: string
  ): Promise<{ uploadUrl: string; fileKey: string }> {
    try {
      // Validar tipo de archivo
      if (!this.isValidFileType(contentType)) {
        throw new BadRequestException('Tipo de archivo no permitido');
      }

      // Asegurar que tenemos una extensi√≥n v√°lida
      const extension = fileExtension || this.getDefaultExtension(contentType);

      // Generar nombre √∫nico para el archivo
      const fileKey = `${folder}/${uuidv4()}.${extension}`;

      const command = new PutObjectCommand({
        Bucket: this.bucketName,
        Key: fileKey,
        ContentType: contentType,
      });

      const uploadUrl = await getSignedUrl(this.s3Client, command, { 
        expiresIn: 3600 
      });

      return { uploadUrl, fileKey };

    } catch (error) {
      console.error('Error generando URL de subida:', error);
      throw new Error('Error generando URL para subida de archivo');
    }
  }

  async deleteFile(fileKey: string): Promise<void> {
    try {
      const command = new DeleteObjectCommand({
        Bucket: this.bucketName,
        Key: fileKey
      });

      await this.s3Client.send(command);
      console.log(`File ${fileKey} deleted successfully from S3`);
    } catch (error) {
      console.error('Error deleting file from S3:', error);
      throw new BadRequestException('Error deleting file from S3');
    }
  }


  private isValidFileType(contentType: string): boolean {
    const allowedTypes = [
      'image/jpeg',
      'image/png',
      'image/webp',
      'application/pdf'
    ];
    return allowedTypes.includes(contentType);
  }

  private getDefaultExtension(contentType: string): string {
    const mimeToExt = {
      'image/jpeg': 'jpg',
      'image/png': 'png',
      'image/webp': 'webp',
      'application/pdf': 'pdf'
    };
    return mimeToExt[contentType] || 'bin';
  }

  async uploadFile(file: Express.Multer.File): Promise<{ fileUrl: string }> {
    try {
      // Validar el archivo
      if (!file) {
        throw new BadRequestException('No file provided');
      }

      // Validar tipo de archivo
      if (!this.isValidFileType(file.mimetype)) {
        throw new BadRequestException('Invalid file type');
      }

      const fileExtension = file.originalname.split('.').pop() || 
                          this.getDefaultExtension(file.mimetype);
      
      const fileKey = `test-uploads/${uuidv4()}.${fileExtension}`;

      const command = new PutObjectCommand({
        Bucket: this.bucketName,
        Key: fileKey,
        Body: file.buffer,
        ContentType: file.mimetype
      });

      await this.s3Client.send(command);

      const fileUrl = `https://${this.bucketName}.s3.${this.region}.amazonaws.com/${fileKey}`;

      return { fileUrl };

    } catch (error) {
      console.error('Error uploading file:', error);
      throw new BadRequestException('Error uploading file to S3');
    }
  }
}
```

## c:\Users\rexma\Desktop\freelance-app\src\app.module.ts
```
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import databaseConfig from './config/database.config';
import { AuthModule } from './auth/auth.module';
import { UsersModule } from './modules/users/users.module';
import { RolesModule } from './modules/roles/roles.module';
import { ServicesModule } from './modules/services/services.module';
import { ContractsModule } from './modules/contracts/contracts.module';
import { DocumentsModule } from './modules/documents/documents.module';
import { AppController } from './app.controller'; // Corregida la importaci√≥n
import { AwsModule } from './modules/aws/aws.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [databaseConfig],
    }),
    TypeOrmModule.forRootAsync({
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => {
        const dbConfig = configService.get('database');
        return {
          ...dbConfig,
          autoLoadEntities: true,
        };
      },
    }),
    AuthModule,
    UsersModule,
    RolesModule,
    ServicesModule,
    ContractsModule,
    DocumentsModule,
    AwsModule,
  ],
  controllers: [AppController],
})
export class AppModule {}
```

## c:\Users\rexma\Desktop\freelance-app\src\modules\aws\aws.module.ts
```
import { Module, forwardRef } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AwsService } from './aws.service';
import { AwsController } from './aws.controller';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [
    ConfigModule,
    forwardRef(() => UsersModule)
  ],
  providers: [AwsService],
  controllers: [AwsController],
  exports: [AwsService],
})
export class AwsModule {}
```

## c:\Users\rexma\Desktop\freelance-app\src\modules\users\users.controller.ts
```
// src/modules/users/users.controller.ts
import { Controller, Post, Body, Get, UseGuards, Req, UploadedFile, UseInterceptors, BadRequestException } from '@nestjs/common';
import { UsersService } from './users.service';
import { FileInterceptor } from '@nestjs/platform-express';
import { CreateUserDto } from './dto/create-user.dto';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import * as bcrypt from 'bcrypt';
import { Request, Express } from 'express';

interface RequestWithUser extends Request {
  user: {
    id: string;
    email: string;
    roles: string[];
  };
}

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post('profile-photo')
  @UseGuards(JwtAuthGuard)
  @UseInterceptors(FileInterceptor('file', {
    limits: {
      fileSize: 5 * 1024 * 1024, // 5MB
    },
    fileFilter: (req, file, cb) => {
      if (!file.mimetype.match(/^image\/(jpg|jpeg|png|gif)$/)) {
        cb(new BadRequestException('Solo se permiten im√°genes'), false);
      }
      cb(null, true);
    },
  }))
  async updateProfilePhoto(
    @UploadedFile() file: Express.Multer.File,
    @Req() req: RequestWithUser
  ) {
    console.log('Token:', req.headers.authorization);
  console.log('User:', req.user);
    try {
      const updatedUser = await this.usersService.updateProfilePhoto(
        req.user.id,
        file
      );

      return {
        status: 'success',
        message: 'Foto de perfil actualizada exitosamente',
        data: {
          id: updatedUser.id,
          foto_perfil: updatedUser.foto_perfil,
          updatedAt: new Date()
        }
      };
    } catch (error) {
      throw new BadRequestException(error.message);
    }
  }

  @Post('register')
  async register(@Body() createUserDto: CreateUserDto) {
    // Hash de la contrase√±a antes de crear el usuario
    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);
    
    // Crear usuario con la contrase√±a hasheada
    const user = await this.usersService.create({
      ...createUserDto,
      password: hashedPassword
    });

    // Retornar el usuario sin la contrase√±a
    const { password, ...result } = user;
    return {
      status: 'success',
      message: 'Usuario registrado exitosamente',
      data: result
    };
  }

  @Get('profile')
  @UseGuards(JwtAuthGuard)
  async getProfile(@Req() req: RequestWithUser) {
    const user = await this.usersService.findOne(req.user.id);
    const { password, ...result } = user;
    return {
      status: 'success',
      data: result
    };
  }

  @Get('me')
  @UseGuards(JwtAuthGuard)
  async getMe(@Req() req: RequestWithUser) {
    const user = await this.usersService.findOne(req.user.id);
    const { password, ...result } = user;
    return {
      status: 'success',
      data: {
        ...result,
        roles: await this.usersService.getUserRoles(req.user.id)
      }
    };
  }
}
```

## c:\Users\rexma\Desktop\freelance-app\src\auth\strategies\jwt.strategy.ts
```
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { UsersService } from '../../modules/users/users.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private configService: ConfigService,
    private usersService: UsersService,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get('JWT_SECRET'),
    });
  }

  async validate(payload: any) {
    try {
      console.log('Validating payload:', payload);
      const user = await this.usersService.findOne(payload.sub);
      console.log('Found user:', user);
      
      return {
        id: payload.sub,
        email: payload.email,
        roles: payload.roles,
      };
    } catch (error) {
      console.error('JWT validation error:', error);
      throw new UnauthorizedException('Token inv√°lido');
    }
  }
}
```

## c:\Users\rexma\Desktop\freelance-app\src\auth\guards\jwt-auth.guard.ts
```
import {
    Injectable,
    ExecutionContext,
    UnauthorizedException,
    Inject,
  } from '@nestjs/common';
  import { AuthGuard } from '@nestjs/passport';
  import { JwtService } from '@nestjs/jwt';
  import { Request } from 'express';
  
  @Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  async canActivate(context: ExecutionContext): Promise<boolean> {
    try {
      // Use Passport's built-in authentication
      const result = await super.canActivate(context);
      return result as boolean;
    } catch (error) {
      console.error('Authentication error:', error);
      throw error;
    }
  }

  handleRequest(err: any, user: any, info: any) {
    console.log('JWT Guard - Handle Request:', { 
      error: err?.message, 
      hasUser: !!user,
      info: info?.message 
    });

    // If there's an error or no user, throw an error
    if (err || !user) {
      throw err || new UnauthorizedException('Invalid token');
    }
    return user;
  }

  constructor(
    @Inject(JwtService)
    private readonly jwtService: JwtService
  ) {
    super();
  }

  

     
  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
```

## c:\Users\rexma\Desktop\freelance-app\src\auth\auth.module.ts
```
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { UsersModule } from '../modules/users/users.module';
import { RefreshToken } from './entities/refresh-token.entity';
import { LoginAttempt } from './entities/login-attempt.entity';
import { TokenService } from './services/token.service';
import { LoginAttemptService } from './services/login-attempt.service';

@Module({
  imports: [
    TypeOrmModule.forFeature([RefreshToken, LoginAttempt]),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: { expiresIn: '15m' },
      }),
      inject: [ConfigService],
    }),
    UsersModule,
  ],
  providers: [TokenService, LoginAttemptService],
  exports: [TokenService, LoginAttemptService],
})
export class AuthModule {}
```

## c:\Users\rexma\Desktop\freelance-app\src\auth\entities\refresh-token.entity.ts
```
import { Column, CreateDateColumn, Entity, JoinColumn, ManyToOne, PrimaryGeneratedColumn, UpdateDateColumn } from 'typeorm';
import { User } from '../../modules/users/entities/user.entity';

@Entity('refresh_tokens')
export class RefreshToken {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  token: string;

  @Column({ name: 'expires_at' })
  expiresAt: Date;

  @ManyToOne(() => User, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'user_id' })
  user: User;

  @Column({ default: false })
  revoked: boolean;

  @Column({ name: 'ip_address', type: 'inet', nullable: true })
  ipAddress: string;

  @Column({ name: 'user_agent', nullable: true })
  userAgent: string;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;

  // M√©todo de utilidad para verificar si el token est√° activo
  isActive(): boolean {
    return !this.revoked && this.expiresAt > new Date();
  }
}
```

## c:\Users\rexma\Desktop\freelance-app\src\auth\services\token.service.ts
```
import { Injectable, UnauthorizedException, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { Request } from 'express';
import { RefreshToken } from '../entities/refresh-token.entity';
import { User } from '../../modules/users/entities/user.entity';
import { AuthTokens } from '../interfaces/auth-tokens.interface';
import { JwtPayload } from '../interfaces/jwt-payload.interface';
import { UsersService } from '../../modules/users/users.service';

@Injectable()
export class TokenService {
  constructor(
    @InjectRepository(RefreshToken)
    private refreshTokenRepo: Repository<RefreshToken>,
    private jwtService: JwtService,
    private configService: ConfigService,
    private userService: UsersService
  ) {}

  async generateAuthTokens(user: User, request: Request): Promise<AuthTokens> {
    const accessToken = await this.generateAccessToken(user);
    const refreshToken = await this.generateRefreshToken(user, request);

    return {
      accessToken,
      refreshToken: refreshToken.token,
      expiresIn: 900
    };
  }

  private async generateAccessToken(user: User): Promise<string> {
    const roles = await this.userService.getUserRoles(user.id);
    
    const payload: JwtPayload = {
      sub: user.id,
      email: user.email,
      roles
    };

    return this.jwtService.sign(payload, {
      secret: this.configService.get('JWT_SECRET'),
      expiresIn: '15m'
    });
  }

  private async generateRefreshToken(user: User, request: Request): Promise<RefreshToken> {
    await this.revokeUserRefreshTokens(user.id);

    const token = this.jwtService.sign(
      { sub: user.id },
      {
        secret: this.configService.get('JWT_REFRESH_SECRET'),
        expiresIn: '7d'
      }
    );

    const refreshToken = this.refreshTokenRepo.create({
      user,
      token,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      ipAddress: request.socket.remoteAddress,
      userAgent: request.headers['user-agent']
    });

    return await this.refreshTokenRepo.save(refreshToken);
  }

  async refreshAccessToken(refreshToken: string, request: Request): Promise<AuthTokens> {
    const token = await this.findAndValidateRefreshToken(refreshToken);
    
    if (!token || !token.isActive()) {
      throw new UnauthorizedException('Invalid refresh token');
    }

    return this.generateAuthTokens(token.user, request);
  }

  private async findAndValidateRefreshToken(token: string): Promise<RefreshToken> {
    const refreshToken = await this.refreshTokenRepo.findOne({
      where: { token, revoked: false },
      relations: ['user']
    });

    if (!refreshToken) {
      throw new UnauthorizedException('Invalid refresh token');
    }

    return refreshToken;
  }

  private async revokeUserRefreshTokens(userId: string): Promise<void> {
    await this.refreshTokenRepo.update(
      { user: { id: userId }, revoked: false },
      { revoked: true }
    );
  }

  async revokeRefreshToken(token: string): Promise<void> {
    const result = await this.refreshTokenRepo.update(
      { token },
      { revoked: true }
    );

    if (result.affected === 0) {
      throw new NotFoundException('Token not found');
    }
  }
}
```

## c:\Users\rexma\Desktop\freelance-app\src\auth\entities\login-attempt.entity.ts
```
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn } from 'typeorm';

@Entity('login_attempts')
export class LoginAttempt {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  email: string;

  @Column({ name: 'ip_address' })
  ipAddress: string;

  @CreateDateColumn()
  timestamp: Date;

  @Column({ default: false })
  successful: boolean;

  @Column({ name: 'user_agent', nullable: true })
  userAgent: string;

  @Column({ type: 'jsonb', nullable: true })
  details: Record<string, any>;
}
```

## c:\Users\rexma\Desktop\freelance-app\src\auth\services\login-attempt.service.ts
```
import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, MoreThan } from 'typeorm';
import { LoginAttempt } from '../entities/login-attempt.entity';

@Injectable()
export class LoginAttemptService {
  private readonly logger = new Logger(LoginAttemptService.name);
  private readonly MAX_ATTEMPTS = 5;
  private readonly ATTEMPT_WINDOW = 30 * 60 * 1000; // 30 minutos

  constructor(
    @InjectRepository(LoginAttempt)
    private readonly loginAttemptRepo: Repository<LoginAttempt>
  ) {}

  async recordAttempt(
    email: string,
    ip: string,
    userAgent: string,
    successful: boolean
  ): Promise<void> {
    try {
      // Creamos un nuevo intento de inicio de sesi√≥n
      const loginAttempt = new LoginAttempt();
      loginAttempt.email = email;
      loginAttempt.ipAddress = ip;
      loginAttempt.userAgent = userAgent;
      loginAttempt.successful = successful;
      loginAttempt.details = {
        timestamp: new Date(),
        successful,
        attemptType: 'login'
      };

      await this.loginAttemptRepo.save(loginAttempt);

      if (!successful) {
        await this.handleFailedAttempt(email, ip);
      }
    } catch (error) {
      this.logger.error(
        `Error registrando intento de inicio de sesi√≥n: ${error.message}`,
        error.stack
      );
      throw error;
    }
  }

  private async handleFailedAttempt(email: string, ip: string): Promise<void> {
    try {
      const recentAttempts = await this.loginAttemptRepo.count({
        where: {
          email,
          ipAddress: ip,
          successful: false,
          timestamp: MoreThan(new Date(Date.now() - this.ATTEMPT_WINDOW))
        }
      });

      if (recentAttempts >= this.MAX_ATTEMPTS) {
        // Creamos un registro de bloqueo
        const blockRecord = new LoginAttempt();
        blockRecord.email = email;
        blockRecord.ipAddress = ip;
        blockRecord.successful = false;
        blockRecord.details = {
          type: 'block',
          reason: 'too_many_attempts',
          attemptCount: recentAttempts,
          blockTimestamp: new Date()
        };

        await this.loginAttemptRepo.save(blockRecord);
        this.logger.warn(`Account blocked: ${email} from IP ${ip}`);
      }
    } catch (error) {
      this.logger.error(
        `Error handling failed login attempt: ${error.message}`,
        error.stack
      );
      throw error;
    }
  }

  async isBlocked(email: string, ip: string): Promise<boolean> {
    try {
      const recentBlock = await this.loginAttemptRepo.findOne({
        where: {
          email,
          ipAddress: ip,
          timestamp: MoreThan(new Date(Date.now() - this.ATTEMPT_WINDOW)),
          details: { type: 'block' }
        },
        order: { timestamp: 'DESC' }
      });

      return !!recentBlock;
    } catch (error) {
      this.logger.error(
        `Error checking block status: ${error.message}`,
        error.stack
      );
      // Por seguridad, si hay un error asumimos que est√° bloqueado
      return true;
    }
  }

  async getRecentAttempts(email: string, ip: string): Promise<LoginAttempt[]> {
    return this.loginAttemptRepo.find({
      where: {
        email,
        ipAddress: ip,
        timestamp: MoreThan(new Date(Date.now() - this.ATTEMPT_WINDOW))
      },
      order: { timestamp: 'DESC' }
    });
  }
}
```

## c:\Users\rexma\Desktop\freelance-app\src\database\migrations\1709123456789-CreateRefreshTokensTable.ts
```
import { MigrationInterface, QueryRunner } from 'typeorm';

export class CreateRefreshTokensTable1709123456789 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      CREATE TABLE refresh_tokens (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        token VARCHAR(255) NOT NULL,
        expires_at TIMESTAMP NOT NULL,
        user_id UUID NOT NULL,
        revoked BOOLEAN DEFAULT FALSE,
        ip_address INET,
        user_agent VARCHAR(255),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        
        -- √çndices para optimizar b√∫squedas
        CONSTRAINT fk_user FOREIGN KEY (user_id) 
          REFERENCES usuarios(id) ON DELETE CASCADE,
        CONSTRAINT uk_token UNIQUE (token)
      );

      -- √çndices para mejorar el rendimiento de las consultas frecuentes
      CREATE INDEX idx_refresh_token_user ON refresh_tokens(user_id);
      CREATE INDEX idx_refresh_token_status ON refresh_tokens(revoked, expires_at);
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP TABLE refresh_tokens`);
  }
}
```

## c:\Users\rexma\Desktop\freelance-app\src\auth\interfaces\auth-tokens.interface.ts
```
export interface AuthTokens {
    accessToken: string;
    refreshToken: string;
    expiresIn: number;
  }
```

## c:\Users\rexma\Desktop\freelance-app\src\auth\interfaces\jwt-payload.interface.ts
```
export interface JwtPayload {
    sub: string;        // ID del usuario
    email: string;      // Email del usuario
    roles: string[];    // Roles del usuario
    iat?: number;       // Fecha de emisi√≥n
    exp?: number;       // Fecha de expiraci√≥n
  }
```

